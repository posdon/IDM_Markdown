/*
 * generated by Xtext 2.12.0
 */
package org.xtext.robot.perdu.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.xtext.robot.perdu.services.MyDslGrammarAccess;
import robot.flotCtrl.AndExp;
import robot.flotCtrl.FlotCtrlPackage;
import robot.flotCtrl.IfBlock;
import robot.flotCtrl.NegExp;
import robot.flotCtrl.WhileLoop;
import robot.robot.Bip;
import robot.robot.HasTurnedCmd;
import robot.robot.MoveCmd;
import robot.robot.ObstacleCmd;
import robot.robot.PrintCmd;
import robot.robot.ProgramUnit;
import robot.robot.RobotPackage;
import robot.robot.SetTurnAngleCmd;
import robot.robot.TurnCmd;

@SuppressWarnings("all")
public class MyDslSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private MyDslGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == FlotCtrlPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case FlotCtrlPackage.AND_EXP:
				sequence_AndExp(context, (AndExp) semanticObject); 
				return; 
			case FlotCtrlPackage.IF_BLOCK:
				sequence_IfBlock(context, (IfBlock) semanticObject); 
				return; 
			case FlotCtrlPackage.NEG_EXP:
				sequence_NegExp(context, (NegExp) semanticObject); 
				return; 
			case FlotCtrlPackage.WHILE_LOOP:
				sequence_WhileLoop(context, (WhileLoop) semanticObject); 
				return; 
			}
		else if (epackage == RobotPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case RobotPackage.BIP:
				sequence_BipCmd(context, (Bip) semanticObject); 
				return; 
			case RobotPackage.HAS_TURNED_CMD:
				sequence_HasTurnedCmd(context, (HasTurnedCmd) semanticObject); 
				return; 
			case RobotPackage.MOVE_CMD:
				sequence_MoveCmd(context, (MoveCmd) semanticObject); 
				return; 
			case RobotPackage.OBSTACLE_CMD:
				sequence_ObstacleCmd(context, (ObstacleCmd) semanticObject); 
				return; 
			case RobotPackage.PRINT_CMD:
				sequence_PrintCmd(context, (PrintCmd) semanticObject); 
				return; 
			case RobotPackage.PROGRAM_UNIT:
				sequence_ProgramUnit(context, (ProgramUnit) semanticObject); 
				return; 
			case RobotPackage.SET_TURN_ANGLE_CMD:
				sequence_SetTurnAngleCmd(context, (SetTurnAngleCmd) semanticObject); 
				return; 
			case RobotPackage.TURN_CMD:
				sequence_TurnCmd(context, (TurnCmd) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Expression returns AndExp
	 *     BoolExp returns AndExp
	 *     AndExp returns AndExp
	 *
	 * Constraint:
	 *     (leftExp=BoolExp rightExp=BoolExp)
	 */
	protected void sequence_AndExp(ISerializationContext context, AndExp semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FlotCtrlPackage.Literals.AND_EXP__LEFT_EXP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FlotCtrlPackage.Literals.AND_EXP__LEFT_EXP));
			if (transientValues.isValueTransient(semanticObject, FlotCtrlPackage.Literals.AND_EXP__RIGHT_EXP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FlotCtrlPackage.Literals.AND_EXP__RIGHT_EXP));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAndExpAccess().getLeftExpBoolExpParserRuleCall_1_0(), semanticObject.getLeftExp());
		feeder.accept(grammarAccess.getAndExpAccess().getRightExpBoolExpParserRuleCall_2_0(), semanticObject.getRightExp());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Bip
	 *     Command returns Bip
	 *     BipCmd returns Bip
	 *
	 * Constraint:
	 *     (duration=INT | power=DOUBLE | repet=BOOLEAN_LITERAL)+
	 */
	protected void sequence_BipCmd(ISerializationContext context, Bip semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns HasTurnedCmd
	 *     BoolExp returns HasTurnedCmd
	 *     Command returns HasTurnedCmd
	 *     HasTurnedCmd returns HasTurnedCmd
	 *
	 * Constraint:
	 *     angle=DOUBLE
	 */
	protected void sequence_HasTurnedCmd(ISerializationContext context, HasTurnedCmd semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RobotPackage.Literals.HAS_TURNED_CMD__ANGLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobotPackage.Literals.HAS_TURNED_CMD__ANGLE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getHasTurnedCmdAccess().getAngleDOUBLETerminalRuleCall_4_0(), semanticObject.getAngle());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns IfBlock
	 *     IfBlock returns IfBlock
	 *
	 * Constraint:
	 *     (condition=BoolExp thenBlock+=Expression thenBlock+=Expression* (elseBlock+=Expression elseBlock+=Expression*)?)
	 */
	protected void sequence_IfBlock(ISerializationContext context, IfBlock semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns MoveCmd
	 *     Command returns MoveCmd
	 *     MoveCmd returns MoveCmd
	 *
	 * Constraint:
	 *     power=DOUBLE
	 */
	protected void sequence_MoveCmd(ISerializationContext context, MoveCmd semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RobotPackage.Literals.MOVE_CMD__POWER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobotPackage.Literals.MOVE_CMD__POWER));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMoveCmdAccess().getPowerDOUBLETerminalRuleCall_4_0(), semanticObject.getPower());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns NegExp
	 *     BoolExp returns NegExp
	 *     NegExp returns NegExp
	 *
	 * Constraint:
	 *     exp=BoolExp
	 */
	protected void sequence_NegExp(ISerializationContext context, NegExp semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FlotCtrlPackage.Literals.NEG_EXP__EXP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FlotCtrlPackage.Literals.NEG_EXP__EXP));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNegExpAccess().getExpBoolExpParserRuleCall_1_0(), semanticObject.getExp());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns ObstacleCmd
	 *     BoolExp returns ObstacleCmd
	 *     Command returns ObstacleCmd
	 *     ObstacleCmd returns ObstacleCmd
	 *
	 * Constraint:
	 *     distance=DOUBLE
	 */
	protected void sequence_ObstacleCmd(ISerializationContext context, ObstacleCmd semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RobotPackage.Literals.OBSTACLE_CMD__DISTANCE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobotPackage.Literals.OBSTACLE_CMD__DISTANCE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getObstacleCmdAccess().getDistanceDOUBLETerminalRuleCall_4_0(), semanticObject.getDistance());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns PrintCmd
	 *     Command returns PrintCmd
	 *     PrintCmd returns PrintCmd
	 *
	 * Constraint:
	 *     (msg=STRING | duration=INT | line=INT | col=INT)+
	 */
	protected void sequence_PrintCmd(ISerializationContext context, PrintCmd semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ProgramUnit returns ProgramUnit
	 *
	 * Constraint:
	 *     block+=Expression*
	 */
	protected void sequence_ProgramUnit(ISerializationContext context, ProgramUnit semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns SetTurnAngleCmd
	 *     Command returns SetTurnAngleCmd
	 *     SetTurnAngleCmd returns SetTurnAngleCmd
	 *
	 * Constraint:
	 *     angle=DOUBLE
	 */
	protected void sequence_SetTurnAngleCmd(ISerializationContext context, SetTurnAngleCmd semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RobotPackage.Literals.SET_TURN_ANGLE_CMD__ANGLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobotPackage.Literals.SET_TURN_ANGLE_CMD__ANGLE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSetTurnAngleCmdAccess().getAngleDOUBLETerminalRuleCall_4_0(), semanticObject.getAngle());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns TurnCmd
	 *     Command returns TurnCmd
	 *     TurnCmd returns TurnCmd
	 *
	 * Constraint:
	 *     (power=DOUBLE | angle=DOUBLE)+
	 */
	protected void sequence_TurnCmd(ISerializationContext context, TurnCmd semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns WhileLoop
	 *     WhileLoop returns WhileLoop
	 *
	 * Constraint:
	 *     (loopCond=BoolExp block+=Expression*)
	 */
	protected void sequence_WhileLoop(ISerializationContext context, WhileLoop semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
