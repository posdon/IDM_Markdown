/*
 * generated by Xtext 2.12.0
 */
package org.xtext.robot.perdu.services;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import java.util.List;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Alternatives;
import org.eclipse.xtext.Assignment;
import org.eclipse.xtext.Grammar;
import org.eclipse.xtext.GrammarUtil;
import org.eclipse.xtext.Group;
import org.eclipse.xtext.Keyword;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.RuleCall;
import org.eclipse.xtext.TerminalRule;
import org.eclipse.xtext.UnorderedGroup;
import org.eclipse.xtext.common.services.TerminalsGrammarAccess;
import org.eclipse.xtext.service.AbstractElementFinder.AbstractGrammarElementFinder;
import org.eclipse.xtext.service.GrammarProvider;

@Singleton
public class MyDslGrammarAccess extends AbstractGrammarElementFinder {
	
	public class ProgramUnitElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.robot.perdu.MyDsl.ProgramUnit");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cProgramUnitAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cBlockAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cBlockExpressionParserRuleCall_1_0 = (RuleCall)cBlockAssignment_1.eContents().get(0);
		
		//ProgramUnit robot::ProgramUnit:
		//	{robot::ProgramUnit} block+=Expression*;
		@Override public ParserRule getRule() { return rule; }
		
		//{robot::ProgramUnit} block+=Expression*
		public Group getGroup() { return cGroup; }
		
		//{robot::ProgramUnit}
		public Action getProgramUnitAction_0() { return cProgramUnitAction_0; }
		
		//block+=Expression*
		public Assignment getBlockAssignment_1() { return cBlockAssignment_1; }
		
		//Expression
		public RuleCall getBlockExpressionParserRuleCall_1_0() { return cBlockExpressionParserRuleCall_1_0; }
	}
	public class ExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.robot.perdu.MyDsl.Expression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cWhileLoopParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cNegExpParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cAndExpParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cIfBlockParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final RuleCall cCommandParserRuleCall_4 = (RuleCall)cAlternatives.eContents().get(4);
		
		//Expression flotCtrl::Expression:
		//	WhileLoop | NegExp | AndExp | IfBlock | Command;
		@Override public ParserRule getRule() { return rule; }
		
		//WhileLoop | NegExp | AndExp | IfBlock | Command
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//WhileLoop
		public RuleCall getWhileLoopParserRuleCall_0() { return cWhileLoopParserRuleCall_0; }
		
		//NegExp
		public RuleCall getNegExpParserRuleCall_1() { return cNegExpParserRuleCall_1; }
		
		//AndExp
		public RuleCall getAndExpParserRuleCall_2() { return cAndExpParserRuleCall_2; }
		
		//IfBlock
		public RuleCall getIfBlockParserRuleCall_3() { return cIfBlockParserRuleCall_3; }
		
		//Command
		public RuleCall getCommandParserRuleCall_4() { return cCommandParserRuleCall_4; }
	}
	public class BoolExpElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.robot.perdu.MyDsl.BoolExp");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cNegExpParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cAndExpParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cBOOLEAN_LITERALParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cHasTurnedCmdParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final RuleCall cObstacleCmdParserRuleCall_4 = (RuleCall)cAlternatives.eContents().get(4);
		
		//BoolExp flotCtrl::BoolExp:
		//	NegExp | AndExp | BOOLEAN_LITERAL | HasTurnedCmd | ObstacleCmd;
		@Override public ParserRule getRule() { return rule; }
		
		//NegExp | AndExp | BOOLEAN_LITERAL | HasTurnedCmd | ObstacleCmd
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//NegExp
		public RuleCall getNegExpParserRuleCall_0() { return cNegExpParserRuleCall_0; }
		
		//AndExp
		public RuleCall getAndExpParserRuleCall_1() { return cAndExpParserRuleCall_1; }
		
		//BOOLEAN_LITERAL
		public RuleCall getBOOLEAN_LITERALParserRuleCall_2() { return cBOOLEAN_LITERALParserRuleCall_2; }
		
		//HasTurnedCmd
		public RuleCall getHasTurnedCmdParserRuleCall_3() { return cHasTurnedCmdParserRuleCall_3; }
		
		//ObstacleCmd
		public RuleCall getObstacleCmdParserRuleCall_4() { return cObstacleCmdParserRuleCall_4; }
	}
	public class WhileLoopElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.robot.perdu.MyDsl.WhileLoop");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cWhileKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cLoopCondAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cLoopCondBoolExpParserRuleCall_1_0 = (RuleCall)cLoopCondAssignment_1.eContents().get(0);
		private final Keyword cDoKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cBlockAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cBlockExpressionParserRuleCall_3_0 = (RuleCall)cBlockAssignment_3.eContents().get(0);
		private final Keyword cEndKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//WhileLoop flotCtrl::WhileLoop:
		//	'while' loopCond=BoolExp 'do'
		//	block+=Expression*
		//	'end';
		@Override public ParserRule getRule() { return rule; }
		
		//'while' loopCond=BoolExp 'do' block+=Expression* 'end'
		public Group getGroup() { return cGroup; }
		
		//'while'
		public Keyword getWhileKeyword_0() { return cWhileKeyword_0; }
		
		//loopCond=BoolExp
		public Assignment getLoopCondAssignment_1() { return cLoopCondAssignment_1; }
		
		//BoolExp
		public RuleCall getLoopCondBoolExpParserRuleCall_1_0() { return cLoopCondBoolExpParserRuleCall_1_0; }
		
		//'do'
		public Keyword getDoKeyword_2() { return cDoKeyword_2; }
		
		//block+=Expression*
		public Assignment getBlockAssignment_3() { return cBlockAssignment_3; }
		
		//Expression
		public RuleCall getBlockExpressionParserRuleCall_3_0() { return cBlockExpressionParserRuleCall_3_0; }
		
		//'end'
		public Keyword getEndKeyword_4() { return cEndKeyword_4; }
	}
	public class NegExpElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.robot.perdu.MyDsl.NegExp");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cNotKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cExpAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cExpBoolExpParserRuleCall_1_0 = (RuleCall)cExpAssignment_1.eContents().get(0);
		
		//NegExp flotCtrl::NegExp:
		//	'not' exp=BoolExp;
		@Override public ParserRule getRule() { return rule; }
		
		//'not' exp=BoolExp
		public Group getGroup() { return cGroup; }
		
		//'not'
		public Keyword getNotKeyword_0() { return cNotKeyword_0; }
		
		//exp=BoolExp
		public Assignment getExpAssignment_1() { return cExpAssignment_1; }
		
		//BoolExp
		public RuleCall getExpBoolExpParserRuleCall_1_0() { return cExpBoolExpParserRuleCall_1_0; }
	}
	public class AndExpElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.robot.perdu.MyDsl.AndExp");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cAndKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cLeftExpAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cLeftExpBoolExpParserRuleCall_1_0 = (RuleCall)cLeftExpAssignment_1.eContents().get(0);
		private final Assignment cRightExpAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cRightExpBoolExpParserRuleCall_2_0 = (RuleCall)cRightExpAssignment_2.eContents().get(0);
		
		//AndExp flotCtrl::AndExp:
		//	'and' leftExp=BoolExp rightExp=BoolExp;
		@Override public ParserRule getRule() { return rule; }
		
		//'and' leftExp=BoolExp rightExp=BoolExp
		public Group getGroup() { return cGroup; }
		
		//'and'
		public Keyword getAndKeyword_0() { return cAndKeyword_0; }
		
		//leftExp=BoolExp
		public Assignment getLeftExpAssignment_1() { return cLeftExpAssignment_1; }
		
		//BoolExp
		public RuleCall getLeftExpBoolExpParserRuleCall_1_0() { return cLeftExpBoolExpParserRuleCall_1_0; }
		
		//rightExp=BoolExp
		public Assignment getRightExpAssignment_2() { return cRightExpAssignment_2; }
		
		//BoolExp
		public RuleCall getRightExpBoolExpParserRuleCall_2_0() { return cRightExpBoolExpParserRuleCall_2_0; }
	}
	public class IfBlockElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.robot.perdu.MyDsl.IfBlock");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cIfKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cConditionAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cConditionBoolExpParserRuleCall_1_0 = (RuleCall)cConditionAssignment_1.eContents().get(0);
		private final Keyword cThenKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cThenBlockAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cThenBlockExpressionParserRuleCall_3_0 = (RuleCall)cThenBlockAssignment_3.eContents().get(0);
		private final Assignment cThenBlockAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cThenBlockExpressionParserRuleCall_4_0 = (RuleCall)cThenBlockAssignment_4.eContents().get(0);
		private final Group cGroup_5 = (Group)cGroup.eContents().get(5);
		private final Keyword cElseKeyword_5_0 = (Keyword)cGroup_5.eContents().get(0);
		private final Assignment cElseBlockAssignment_5_1 = (Assignment)cGroup_5.eContents().get(1);
		private final RuleCall cElseBlockExpressionParserRuleCall_5_1_0 = (RuleCall)cElseBlockAssignment_5_1.eContents().get(0);
		private final Assignment cElseBlockAssignment_5_2 = (Assignment)cGroup_5.eContents().get(2);
		private final RuleCall cElseBlockExpressionParserRuleCall_5_2_0 = (RuleCall)cElseBlockAssignment_5_2.eContents().get(0);
		private final Keyword cEndKeyword_6 = (Keyword)cGroup.eContents().get(6);
		
		//IfBlock flotCtrl::IfBlock:
		//	'if' condition=BoolExp 'then'
		//	thenBlock+=Expression thenBlock+=Expression* ('else' elseBlock+=Expression elseBlock+=Expression*)?
		//	'end';
		@Override public ParserRule getRule() { return rule; }
		
		//'if' condition=BoolExp 'then' thenBlock+=Expression thenBlock+=Expression* ('else' elseBlock+=Expression
		//elseBlock+=Expression*)? 'end'
		public Group getGroup() { return cGroup; }
		
		//'if'
		public Keyword getIfKeyword_0() { return cIfKeyword_0; }
		
		//condition=BoolExp
		public Assignment getConditionAssignment_1() { return cConditionAssignment_1; }
		
		//BoolExp
		public RuleCall getConditionBoolExpParserRuleCall_1_0() { return cConditionBoolExpParserRuleCall_1_0; }
		
		//'then'
		public Keyword getThenKeyword_2() { return cThenKeyword_2; }
		
		//thenBlock+=Expression
		public Assignment getThenBlockAssignment_3() { return cThenBlockAssignment_3; }
		
		//Expression
		public RuleCall getThenBlockExpressionParserRuleCall_3_0() { return cThenBlockExpressionParserRuleCall_3_0; }
		
		//thenBlock+=Expression*
		public Assignment getThenBlockAssignment_4() { return cThenBlockAssignment_4; }
		
		//Expression
		public RuleCall getThenBlockExpressionParserRuleCall_4_0() { return cThenBlockExpressionParserRuleCall_4_0; }
		
		//('else' elseBlock+=Expression elseBlock+=Expression*)?
		public Group getGroup_5() { return cGroup_5; }
		
		//'else'
		public Keyword getElseKeyword_5_0() { return cElseKeyword_5_0; }
		
		//elseBlock+=Expression
		public Assignment getElseBlockAssignment_5_1() { return cElseBlockAssignment_5_1; }
		
		//Expression
		public RuleCall getElseBlockExpressionParserRuleCall_5_1_0() { return cElseBlockExpressionParserRuleCall_5_1_0; }
		
		//elseBlock+=Expression*
		public Assignment getElseBlockAssignment_5_2() { return cElseBlockAssignment_5_2; }
		
		//Expression
		public RuleCall getElseBlockExpressionParserRuleCall_5_2_0() { return cElseBlockExpressionParserRuleCall_5_2_0; }
		
		//'end'
		public Keyword getEndKeyword_6() { return cEndKeyword_6; }
	}
	public class CommandElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.robot.perdu.MyDsl.Command");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cMoveCmdParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cObstacleCmdParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cBipCmdParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cSetTurnAngleCmdParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final RuleCall cHasTurnedCmdParserRuleCall_4 = (RuleCall)cAlternatives.eContents().get(4);
		private final RuleCall cTurnCmdParserRuleCall_5 = (RuleCall)cAlternatives.eContents().get(5);
		private final RuleCall cStopEngineCmdParserRuleCall_6 = (RuleCall)cAlternatives.eContents().get(6);
		private final RuleCall cStopProgramCmdParserRuleCall_7 = (RuleCall)cAlternatives.eContents().get(7);
		private final RuleCall cPrintCmdParserRuleCall_8 = (RuleCall)cAlternatives.eContents().get(8);
		
		//Command robot::Command:
		//	MoveCmd | ObstacleCmd | BipCmd | SetTurnAngleCmd | HasTurnedCmd | TurnCmd | StopEngineCmd | StopProgramCmd | PrintCmd;
		@Override public ParserRule getRule() { return rule; }
		
		//MoveCmd | ObstacleCmd | BipCmd | SetTurnAngleCmd | HasTurnedCmd | TurnCmd | StopEngineCmd | StopProgramCmd | PrintCmd
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//MoveCmd
		public RuleCall getMoveCmdParserRuleCall_0() { return cMoveCmdParserRuleCall_0; }
		
		//ObstacleCmd
		public RuleCall getObstacleCmdParserRuleCall_1() { return cObstacleCmdParserRuleCall_1; }
		
		//BipCmd
		public RuleCall getBipCmdParserRuleCall_2() { return cBipCmdParserRuleCall_2; }
		
		//SetTurnAngleCmd
		public RuleCall getSetTurnAngleCmdParserRuleCall_3() { return cSetTurnAngleCmdParserRuleCall_3; }
		
		//HasTurnedCmd
		public RuleCall getHasTurnedCmdParserRuleCall_4() { return cHasTurnedCmdParserRuleCall_4; }
		
		//TurnCmd
		public RuleCall getTurnCmdParserRuleCall_5() { return cTurnCmdParserRuleCall_5; }
		
		//StopEngineCmd
		public RuleCall getStopEngineCmdParserRuleCall_6() { return cStopEngineCmdParserRuleCall_6; }
		
		//StopProgramCmd
		public RuleCall getStopProgramCmdParserRuleCall_7() { return cStopProgramCmdParserRuleCall_7; }
		
		//PrintCmd
		public RuleCall getPrintCmdParserRuleCall_8() { return cPrintCmdParserRuleCall_8; }
	}
	public class PrintCmdElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.robot.perdu.MyDsl.PrintCmd");
		private final UnorderedGroup cUnorderedGroup = (UnorderedGroup)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cUnorderedGroup.eContents().get(0);
		private final Keyword cDisplayKeyword_0_0 = (Keyword)cGroup_0.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_0_1 = (Keyword)cGroup_0.eContents().get(1);
		private final Group cGroup_0_2 = (Group)cGroup_0.eContents().get(2);
		private final Keyword cMsgKeyword_0_2_0 = (Keyword)cGroup_0_2.eContents().get(0);
		private final Keyword cEqualsSignKeyword_0_2_1 = (Keyword)cGroup_0_2.eContents().get(1);
		private final Assignment cMsgAssignment_0_2_2 = (Assignment)cGroup_0_2.eContents().get(2);
		private final RuleCall cMsgSTRINGTerminalRuleCall_0_2_2_0 = (RuleCall)cMsgAssignment_0_2_2.eContents().get(0);
		private final Keyword cCommaKeyword_0_2_3 = (Keyword)cGroup_0_2.eContents().get(3);
		private final Group cGroup_1 = (Group)cUnorderedGroup.eContents().get(1);
		private final Keyword cDurationKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Keyword cEqualsSignKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cDurationAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cDurationINTTerminalRuleCall_1_2_0 = (RuleCall)cDurationAssignment_1_2.eContents().get(0);
		private final Keyword cCommaKeyword_1_3 = (Keyword)cGroup_1.eContents().get(3);
		private final Group cGroup_2 = (Group)cUnorderedGroup.eContents().get(2);
		private final Keyword cLineKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Keyword cEqualsSignKeyword_2_1 = (Keyword)cGroup_2.eContents().get(1);
		private final Assignment cLineAssignment_2_2 = (Assignment)cGroup_2.eContents().get(2);
		private final RuleCall cLineINTTerminalRuleCall_2_2_0 = (RuleCall)cLineAssignment_2_2.eContents().get(0);
		private final Keyword cCommaKeyword_2_3 = (Keyword)cGroup_2.eContents().get(3);
		private final Group cGroup_3 = (Group)cUnorderedGroup.eContents().get(3);
		private final Group cGroup_3_0 = (Group)cGroup_3.eContents().get(0);
		private final Keyword cColKeyword_3_0_0 = (Keyword)cGroup_3_0.eContents().get(0);
		private final Keyword cEqualsSignKeyword_3_0_1 = (Keyword)cGroup_3_0.eContents().get(1);
		private final Assignment cColAssignment_3_0_2 = (Assignment)cGroup_3_0.eContents().get(2);
		private final RuleCall cColINTTerminalRuleCall_3_0_2_0 = (RuleCall)cColAssignment_3_0_2.eContents().get(0);
		private final Keyword cCommaKeyword_3_0_3 = (Keyword)cGroup_3_0.eContents().get(3);
		private final Keyword cRightParenthesisKeyword_3_1 = (Keyword)cGroup_3.eContents().get(1);
		
		//PrintCmd robot::PrintCmd:
		//	'display' '(' ('msg' '=' msg=STRING ','?) & 'duration' '=' duration=INT ','? & 'line' '=' line=INT ','? & ('col' '='
		//	col=INT ','?)
		//	')';
		@Override public ParserRule getRule() { return rule; }
		
		//'display' '(' ('msg' '=' msg=STRING ','?) & 'duration' '=' duration=INT ','? & 'line' '=' line=INT ','? & ('col' '='
		//col=INT ','?) ')'
		public UnorderedGroup getUnorderedGroup() { return cUnorderedGroup; }
		
		//'display' '(' ('msg' '=' msg=STRING ','?)
		public Group getGroup_0() { return cGroup_0; }
		
		//'display'
		public Keyword getDisplayKeyword_0_0() { return cDisplayKeyword_0_0; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_0_1() { return cLeftParenthesisKeyword_0_1; }
		
		//'msg' '=' msg=STRING ','?
		public Group getGroup_0_2() { return cGroup_0_2; }
		
		//'msg'
		public Keyword getMsgKeyword_0_2_0() { return cMsgKeyword_0_2_0; }
		
		//'='
		public Keyword getEqualsSignKeyword_0_2_1() { return cEqualsSignKeyword_0_2_1; }
		
		//msg=STRING
		public Assignment getMsgAssignment_0_2_2() { return cMsgAssignment_0_2_2; }
		
		//STRING
		public RuleCall getMsgSTRINGTerminalRuleCall_0_2_2_0() { return cMsgSTRINGTerminalRuleCall_0_2_2_0; }
		
		//','?
		public Keyword getCommaKeyword_0_2_3() { return cCommaKeyword_0_2_3; }
		
		//'duration' '=' duration=INT ','?
		public Group getGroup_1() { return cGroup_1; }
		
		//'duration'
		public Keyword getDurationKeyword_1_0() { return cDurationKeyword_1_0; }
		
		//'='
		public Keyword getEqualsSignKeyword_1_1() { return cEqualsSignKeyword_1_1; }
		
		//duration=INT
		public Assignment getDurationAssignment_1_2() { return cDurationAssignment_1_2; }
		
		//INT
		public RuleCall getDurationINTTerminalRuleCall_1_2_0() { return cDurationINTTerminalRuleCall_1_2_0; }
		
		//','?
		public Keyword getCommaKeyword_1_3() { return cCommaKeyword_1_3; }
		
		//'line' '=' line=INT ','?
		public Group getGroup_2() { return cGroup_2; }
		
		//'line'
		public Keyword getLineKeyword_2_0() { return cLineKeyword_2_0; }
		
		//'='
		public Keyword getEqualsSignKeyword_2_1() { return cEqualsSignKeyword_2_1; }
		
		//line=INT
		public Assignment getLineAssignment_2_2() { return cLineAssignment_2_2; }
		
		//INT
		public RuleCall getLineINTTerminalRuleCall_2_2_0() { return cLineINTTerminalRuleCall_2_2_0; }
		
		//','?
		public Keyword getCommaKeyword_2_3() { return cCommaKeyword_2_3; }
		
		//('col' '=' col=INT ','?) ')'
		public Group getGroup_3() { return cGroup_3; }
		
		//'col' '=' col=INT ','?
		public Group getGroup_3_0() { return cGroup_3_0; }
		
		//'col'
		public Keyword getColKeyword_3_0_0() { return cColKeyword_3_0_0; }
		
		//'='
		public Keyword getEqualsSignKeyword_3_0_1() { return cEqualsSignKeyword_3_0_1; }
		
		//col=INT
		public Assignment getColAssignment_3_0_2() { return cColAssignment_3_0_2; }
		
		//INT
		public RuleCall getColINTTerminalRuleCall_3_0_2_0() { return cColINTTerminalRuleCall_3_0_2_0; }
		
		//','?
		public Keyword getCommaKeyword_3_0_3() { return cCommaKeyword_3_0_3; }
		
		//')'
		public Keyword getRightParenthesisKeyword_3_1() { return cRightParenthesisKeyword_3_1; }
	}
	public class StopEngineCmdElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.robot.perdu.MyDsl.StopEngineCmd");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cStopEngineKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Keyword cRightParenthesisKeyword_2 = (Keyword)cGroup.eContents().get(2);
		
		//StopEngineCmd robot::StopEngineCmd:
		//	'stopEngine' '(' ')';
		@Override public ParserRule getRule() { return rule; }
		
		//'stopEngine' '(' ')'
		public Group getGroup() { return cGroup; }
		
		//'stopEngine'
		public Keyword getStopEngineKeyword_0() { return cStopEngineKeyword_0; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }
		
		//')'
		public Keyword getRightParenthesisKeyword_2() { return cRightParenthesisKeyword_2; }
	}
	public class StopProgramCmdElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.robot.perdu.MyDsl.StopProgramCmd");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cStopProgramKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Keyword cRightParenthesisKeyword_2 = (Keyword)cGroup.eContents().get(2);
		
		//StopProgramCmd robot::StopProgramCmd:
		//	'stopProgram' '(' ')';
		@Override public ParserRule getRule() { return rule; }
		
		//'stopProgram' '(' ')'
		public Group getGroup() { return cGroup; }
		
		//'stopProgram'
		public Keyword getStopProgramKeyword_0() { return cStopProgramKeyword_0; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }
		
		//')'
		public Keyword getRightParenthesisKeyword_2() { return cRightParenthesisKeyword_2; }
	}
	public class TurnCmdElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.robot.perdu.MyDsl.TurnCmd");
		private final UnorderedGroup cUnorderedGroup = (UnorderedGroup)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cUnorderedGroup.eContents().get(0);
		private final Keyword cTurnKeyword_0_0 = (Keyword)cGroup_0.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_0_1 = (Keyword)cGroup_0.eContents().get(1);
		private final Group cGroup_0_2 = (Group)cGroup_0.eContents().get(2);
		private final Keyword cPowerKeyword_0_2_0 = (Keyword)cGroup_0_2.eContents().get(0);
		private final Keyword cEqualsSignKeyword_0_2_1 = (Keyword)cGroup_0_2.eContents().get(1);
		private final Assignment cPowerAssignment_0_2_2 = (Assignment)cGroup_0_2.eContents().get(2);
		private final RuleCall cPowerDOUBLETerminalRuleCall_0_2_2_0 = (RuleCall)cPowerAssignment_0_2_2.eContents().get(0);
		private final Keyword cCommaKeyword_0_2_3 = (Keyword)cGroup_0_2.eContents().get(3);
		private final Group cGroup_1 = (Group)cUnorderedGroup.eContents().get(1);
		private final Group cGroup_1_0 = (Group)cGroup_1.eContents().get(0);
		private final Keyword cAngleKeyword_1_0_0 = (Keyword)cGroup_1_0.eContents().get(0);
		private final Keyword cEqualsSignKeyword_1_0_1 = (Keyword)cGroup_1_0.eContents().get(1);
		private final Assignment cAngleAssignment_1_0_2 = (Assignment)cGroup_1_0.eContents().get(2);
		private final RuleCall cAngleDOUBLETerminalRuleCall_1_0_2_0 = (RuleCall)cAngleAssignment_1_0_2.eContents().get(0);
		private final Keyword cCommaKeyword_1_0_3 = (Keyword)cGroup_1_0.eContents().get(3);
		private final Keyword cRightParenthesisKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		
		//TurnCmd robot::TurnCmd:
		//	'turn' '(' ('power' '=' power=DOUBLE ','?) & ('angle' '=' angle=DOUBLE ','?)
		//	')';
		@Override public ParserRule getRule() { return rule; }
		
		//'turn' '(' ('power' '=' power=DOUBLE ','?) & ('angle' '=' angle=DOUBLE ','?) ')'
		public UnorderedGroup getUnorderedGroup() { return cUnorderedGroup; }
		
		//'turn' '(' ('power' '=' power=DOUBLE ','?)
		public Group getGroup_0() { return cGroup_0; }
		
		//'turn'
		public Keyword getTurnKeyword_0_0() { return cTurnKeyword_0_0; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_0_1() { return cLeftParenthesisKeyword_0_1; }
		
		//'power' '=' power=DOUBLE ','?
		public Group getGroup_0_2() { return cGroup_0_2; }
		
		//'power'
		public Keyword getPowerKeyword_0_2_0() { return cPowerKeyword_0_2_0; }
		
		//'='
		public Keyword getEqualsSignKeyword_0_2_1() { return cEqualsSignKeyword_0_2_1; }
		
		//power=DOUBLE
		public Assignment getPowerAssignment_0_2_2() { return cPowerAssignment_0_2_2; }
		
		//DOUBLE
		public RuleCall getPowerDOUBLETerminalRuleCall_0_2_2_0() { return cPowerDOUBLETerminalRuleCall_0_2_2_0; }
		
		//','?
		public Keyword getCommaKeyword_0_2_3() { return cCommaKeyword_0_2_3; }
		
		//('angle' '=' angle=DOUBLE ','?) ')'
		public Group getGroup_1() { return cGroup_1; }
		
		//'angle' '=' angle=DOUBLE ','?
		public Group getGroup_1_0() { return cGroup_1_0; }
		
		//'angle'
		public Keyword getAngleKeyword_1_0_0() { return cAngleKeyword_1_0_0; }
		
		//'='
		public Keyword getEqualsSignKeyword_1_0_1() { return cEqualsSignKeyword_1_0_1; }
		
		//angle=DOUBLE
		public Assignment getAngleAssignment_1_0_2() { return cAngleAssignment_1_0_2; }
		
		//DOUBLE
		public RuleCall getAngleDOUBLETerminalRuleCall_1_0_2_0() { return cAngleDOUBLETerminalRuleCall_1_0_2_0; }
		
		//','?
		public Keyword getCommaKeyword_1_0_3() { return cCommaKeyword_1_0_3; }
		
		//')'
		public Keyword getRightParenthesisKeyword_1_1() { return cRightParenthesisKeyword_1_1; }
	}
	public class HasTurnedCmdElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.robot.perdu.MyDsl.HasTurnedCmd");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cHasTurnedKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Keyword cAngleKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Keyword cEqualsSignKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cAngleAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cAngleDOUBLETerminalRuleCall_4_0 = (RuleCall)cAngleAssignment_4.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_5 = (Keyword)cGroup.eContents().get(5);
		
		//HasTurnedCmd robot::HasTurnedCmd:
		//	'hasTurned' '('
		//	'angle' '=' angle=DOUBLE
		//	')';
		@Override public ParserRule getRule() { return rule; }
		
		//'hasTurned' '(' 'angle' '=' angle=DOUBLE ')'
		public Group getGroup() { return cGroup; }
		
		//'hasTurned'
		public Keyword getHasTurnedKeyword_0() { return cHasTurnedKeyword_0; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }
		
		//'angle'
		public Keyword getAngleKeyword_2() { return cAngleKeyword_2; }
		
		//'='
		public Keyword getEqualsSignKeyword_3() { return cEqualsSignKeyword_3; }
		
		//angle=DOUBLE
		public Assignment getAngleAssignment_4() { return cAngleAssignment_4; }
		
		//DOUBLE
		public RuleCall getAngleDOUBLETerminalRuleCall_4_0() { return cAngleDOUBLETerminalRuleCall_4_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_5() { return cRightParenthesisKeyword_5; }
	}
	public class ObstacleCmdElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.robot.perdu.MyDsl.ObstacleCmd");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cObstacleKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Keyword cDistanceKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Keyword cEqualsSignKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cDistanceAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cDistanceDOUBLETerminalRuleCall_4_0 = (RuleCall)cDistanceAssignment_4.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_5 = (Keyword)cGroup.eContents().get(5);
		
		//ObstacleCmd robot::ObstacleCmd:
		//	'obstacle' '('
		//	'distance' '=' distance=DOUBLE
		//	')';
		@Override public ParserRule getRule() { return rule; }
		
		//'obstacle' '(' 'distance' '=' distance=DOUBLE ')'
		public Group getGroup() { return cGroup; }
		
		//'obstacle'
		public Keyword getObstacleKeyword_0() { return cObstacleKeyword_0; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }
		
		//'distance'
		public Keyword getDistanceKeyword_2() { return cDistanceKeyword_2; }
		
		//'='
		public Keyword getEqualsSignKeyword_3() { return cEqualsSignKeyword_3; }
		
		//distance=DOUBLE
		public Assignment getDistanceAssignment_4() { return cDistanceAssignment_4; }
		
		//DOUBLE
		public RuleCall getDistanceDOUBLETerminalRuleCall_4_0() { return cDistanceDOUBLETerminalRuleCall_4_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_5() { return cRightParenthesisKeyword_5; }
	}
	public class BipCmdElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.robot.perdu.MyDsl.BipCmd");
		private final UnorderedGroup cUnorderedGroup = (UnorderedGroup)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cUnorderedGroup.eContents().get(0);
		private final Keyword cBipKeyword_0_0 = (Keyword)cGroup_0.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_0_1 = (Keyword)cGroup_0.eContents().get(1);
		private final Group cGroup_0_2 = (Group)cGroup_0.eContents().get(2);
		private final Keyword cDurationKeyword_0_2_0 = (Keyword)cGroup_0_2.eContents().get(0);
		private final Keyword cEqualsSignKeyword_0_2_1 = (Keyword)cGroup_0_2.eContents().get(1);
		private final Assignment cDurationAssignment_0_2_2 = (Assignment)cGroup_0_2.eContents().get(2);
		private final RuleCall cDurationINTTerminalRuleCall_0_2_2_0 = (RuleCall)cDurationAssignment_0_2_2.eContents().get(0);
		private final Keyword cCommaKeyword_0_2_3 = (Keyword)cGroup_0_2.eContents().get(3);
		private final Group cGroup_1 = (Group)cUnorderedGroup.eContents().get(1);
		private final Keyword cPowerKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Keyword cEqualsSignKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cPowerAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cPowerDOUBLETerminalRuleCall_1_2_0 = (RuleCall)cPowerAssignment_1_2.eContents().get(0);
		private final Keyword cCommaKeyword_1_3 = (Keyword)cGroup_1.eContents().get(3);
		private final Group cGroup_2 = (Group)cUnorderedGroup.eContents().get(2);
		private final Group cGroup_2_0 = (Group)cGroup_2.eContents().get(0);
		private final Keyword cRepeatKeyword_2_0_0 = (Keyword)cGroup_2_0.eContents().get(0);
		private final Keyword cEqualsSignKeyword_2_0_1 = (Keyword)cGroup_2_0.eContents().get(1);
		private final Assignment cRepetAssignment_2_0_2 = (Assignment)cGroup_2_0.eContents().get(2);
		private final RuleCall cRepetBOOLEAN_LITERALParserRuleCall_2_0_2_0 = (RuleCall)cRepetAssignment_2_0_2.eContents().get(0);
		private final Keyword cCommaKeyword_2_0_3 = (Keyword)cGroup_2_0.eContents().get(3);
		private final Keyword cRightParenthesisKeyword_2_1 = (Keyword)cGroup_2.eContents().get(1);
		
		//BipCmd robot::Bip:
		//	'bip' '(' ('duration' '=' duration=INT ','?) & 'power' '=' power=DOUBLE ','? & ('repeat' '=' repet=BOOLEAN_LITERAL
		//	','?)
		//	')';
		@Override public ParserRule getRule() { return rule; }
		
		//'bip' '(' ('duration' '=' duration=INT ','?) & 'power' '=' power=DOUBLE ','? & ('repeat' '=' repet=BOOLEAN_LITERAL ','?)
		//')'
		public UnorderedGroup getUnorderedGroup() { return cUnorderedGroup; }
		
		//'bip' '(' ('duration' '=' duration=INT ','?)
		public Group getGroup_0() { return cGroup_0; }
		
		//'bip'
		public Keyword getBipKeyword_0_0() { return cBipKeyword_0_0; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_0_1() { return cLeftParenthesisKeyword_0_1; }
		
		//'duration' '=' duration=INT ','?
		public Group getGroup_0_2() { return cGroup_0_2; }
		
		//'duration'
		public Keyword getDurationKeyword_0_2_0() { return cDurationKeyword_0_2_0; }
		
		//'='
		public Keyword getEqualsSignKeyword_0_2_1() { return cEqualsSignKeyword_0_2_1; }
		
		//duration=INT
		public Assignment getDurationAssignment_0_2_2() { return cDurationAssignment_0_2_2; }
		
		//INT
		public RuleCall getDurationINTTerminalRuleCall_0_2_2_0() { return cDurationINTTerminalRuleCall_0_2_2_0; }
		
		//','?
		public Keyword getCommaKeyword_0_2_3() { return cCommaKeyword_0_2_3; }
		
		//'power' '=' power=DOUBLE ','?
		public Group getGroup_1() { return cGroup_1; }
		
		//'power'
		public Keyword getPowerKeyword_1_0() { return cPowerKeyword_1_0; }
		
		//'='
		public Keyword getEqualsSignKeyword_1_1() { return cEqualsSignKeyword_1_1; }
		
		//power=DOUBLE
		public Assignment getPowerAssignment_1_2() { return cPowerAssignment_1_2; }
		
		//DOUBLE
		public RuleCall getPowerDOUBLETerminalRuleCall_1_2_0() { return cPowerDOUBLETerminalRuleCall_1_2_0; }
		
		//','?
		public Keyword getCommaKeyword_1_3() { return cCommaKeyword_1_3; }
		
		//('repeat' '=' repet=BOOLEAN_LITERAL ','?) ')'
		public Group getGroup_2() { return cGroup_2; }
		
		//'repeat' '=' repet=BOOLEAN_LITERAL ','?
		public Group getGroup_2_0() { return cGroup_2_0; }
		
		//'repeat'
		public Keyword getRepeatKeyword_2_0_0() { return cRepeatKeyword_2_0_0; }
		
		//'='
		public Keyword getEqualsSignKeyword_2_0_1() { return cEqualsSignKeyword_2_0_1; }
		
		//repet=BOOLEAN_LITERAL
		public Assignment getRepetAssignment_2_0_2() { return cRepetAssignment_2_0_2; }
		
		//BOOLEAN_LITERAL
		public RuleCall getRepetBOOLEAN_LITERALParserRuleCall_2_0_2_0() { return cRepetBOOLEAN_LITERALParserRuleCall_2_0_2_0; }
		
		//','?
		public Keyword getCommaKeyword_2_0_3() { return cCommaKeyword_2_0_3; }
		
		//')'
		public Keyword getRightParenthesisKeyword_2_1() { return cRightParenthesisKeyword_2_1; }
	}
	public class SetTurnAngleCmdElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.robot.perdu.MyDsl.SetTurnAngleCmd");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cSetTurnAngleKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Keyword cAngleKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Keyword cEqualsSignKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cAngleAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cAngleDOUBLETerminalRuleCall_4_0 = (RuleCall)cAngleAssignment_4.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_5 = (Keyword)cGroup.eContents().get(5);
		
		//SetTurnAngleCmd robot::SetTurnAngleCmd:
		//	'setTurnAngle' '('
		//	'angle' '=' angle=DOUBLE
		//	')';
		@Override public ParserRule getRule() { return rule; }
		
		//'setTurnAngle' '(' 'angle' '=' angle=DOUBLE ')'
		public Group getGroup() { return cGroup; }
		
		//'setTurnAngle'
		public Keyword getSetTurnAngleKeyword_0() { return cSetTurnAngleKeyword_0; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }
		
		//'angle'
		public Keyword getAngleKeyword_2() { return cAngleKeyword_2; }
		
		//'='
		public Keyword getEqualsSignKeyword_3() { return cEqualsSignKeyword_3; }
		
		//angle=DOUBLE
		public Assignment getAngleAssignment_4() { return cAngleAssignment_4; }
		
		//DOUBLE
		public RuleCall getAngleDOUBLETerminalRuleCall_4_0() { return cAngleDOUBLETerminalRuleCall_4_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_5() { return cRightParenthesisKeyword_5; }
	}
	public class MoveCmdElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.robot.perdu.MyDsl.MoveCmd");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cMoveKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Keyword cPowerKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Keyword cEqualsSignKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cPowerAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cPowerDOUBLETerminalRuleCall_4_0 = (RuleCall)cPowerAssignment_4.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_5 = (Keyword)cGroup.eContents().get(5);
		
		//MoveCmd robot::MoveCmd:
		//	'move' '('
		//	'power' '=' power=DOUBLE
		//	')';
		@Override public ParserRule getRule() { return rule; }
		
		//'move' '(' 'power' '=' power=DOUBLE ')'
		public Group getGroup() { return cGroup; }
		
		//'move'
		public Keyword getMoveKeyword_0() { return cMoveKeyword_0; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }
		
		//'power'
		public Keyword getPowerKeyword_2() { return cPowerKeyword_2; }
		
		//'='
		public Keyword getEqualsSignKeyword_3() { return cEqualsSignKeyword_3; }
		
		//power=DOUBLE
		public Assignment getPowerAssignment_4() { return cPowerAssignment_4; }
		
		//DOUBLE
		public RuleCall getPowerDOUBLETerminalRuleCall_4_0() { return cPowerDOUBLETerminalRuleCall_4_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_5() { return cRightParenthesisKeyword_5; }
	}
	public class BOOLEAN_LITERALElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.robot.perdu.MyDsl.BOOLEAN_LITERAL");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cTrueKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cFalseKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		
		//BOOLEAN_LITERAL ecore::EBoolean:
		//	'true' | 'false';
		@Override public ParserRule getRule() { return rule; }
		
		//'true' | 'false'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//'true'
		public Keyword getTrueKeyword_0() { return cTrueKeyword_0; }
		
		//'false'
		public Keyword getFalseKeyword_1() { return cFalseKeyword_1; }
	}
	
	
	private final ProgramUnitElements pProgramUnit;
	private final ExpressionElements pExpression;
	private final BoolExpElements pBoolExp;
	private final WhileLoopElements pWhileLoop;
	private final NegExpElements pNegExp;
	private final AndExpElements pAndExp;
	private final IfBlockElements pIfBlock;
	private final CommandElements pCommand;
	private final PrintCmdElements pPrintCmd;
	private final StopEngineCmdElements pStopEngineCmd;
	private final StopProgramCmdElements pStopProgramCmd;
	private final TurnCmdElements pTurnCmd;
	private final HasTurnedCmdElements pHasTurnedCmd;
	private final ObstacleCmdElements pObstacleCmd;
	private final BipCmdElements pBipCmd;
	private final SetTurnAngleCmdElements pSetTurnAngleCmd;
	private final MoveCmdElements pMoveCmd;
	private final BOOLEAN_LITERALElements pBOOLEAN_LITERAL;
	private final TerminalRule tSTRING;
	private final TerminalRule tML_COMMENT;
	private final TerminalRule tSL_COMMENT;
	private final TerminalRule tWS;
	private final TerminalRule tDIGIT;
	private final TerminalRule tDOUBLE;
	private final TerminalRule tINT;
	
	private final Grammar grammar;
	
	private final TerminalsGrammarAccess gaTerminals;

	@Inject
	public MyDslGrammarAccess(GrammarProvider grammarProvider,
			TerminalsGrammarAccess gaTerminals) {
		this.grammar = internalFindGrammar(grammarProvider);
		this.gaTerminals = gaTerminals;
		this.pProgramUnit = new ProgramUnitElements();
		this.pExpression = new ExpressionElements();
		this.pBoolExp = new BoolExpElements();
		this.pWhileLoop = new WhileLoopElements();
		this.pNegExp = new NegExpElements();
		this.pAndExp = new AndExpElements();
		this.pIfBlock = new IfBlockElements();
		this.pCommand = new CommandElements();
		this.pPrintCmd = new PrintCmdElements();
		this.pStopEngineCmd = new StopEngineCmdElements();
		this.pStopProgramCmd = new StopProgramCmdElements();
		this.pTurnCmd = new TurnCmdElements();
		this.pHasTurnedCmd = new HasTurnedCmdElements();
		this.pObstacleCmd = new ObstacleCmdElements();
		this.pBipCmd = new BipCmdElements();
		this.pSetTurnAngleCmd = new SetTurnAngleCmdElements();
		this.pMoveCmd = new MoveCmdElements();
		this.pBOOLEAN_LITERAL = new BOOLEAN_LITERALElements();
		this.tSTRING = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.robot.perdu.MyDsl.STRING");
		this.tML_COMMENT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.robot.perdu.MyDsl.ML_COMMENT");
		this.tSL_COMMENT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.robot.perdu.MyDsl.SL_COMMENT");
		this.tWS = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.robot.perdu.MyDsl.WS");
		this.tDIGIT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.robot.perdu.MyDsl.DIGIT");
		this.tDOUBLE = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.robot.perdu.MyDsl.DOUBLE");
		this.tINT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.robot.perdu.MyDsl.INT");
	}
	
	protected Grammar internalFindGrammar(GrammarProvider grammarProvider) {
		Grammar grammar = grammarProvider.getGrammar(this);
		while (grammar != null) {
			if ("org.xtext.robot.perdu.MyDsl".equals(grammar.getName())) {
				return grammar;
			}
			List<Grammar> grammars = grammar.getUsedGrammars();
			if (!grammars.isEmpty()) {
				grammar = grammars.iterator().next();
			} else {
				return null;
			}
		}
		return grammar;
	}
	
	@Override
	public Grammar getGrammar() {
		return grammar;
	}
	
	
	public TerminalsGrammarAccess getTerminalsGrammarAccess() {
		return gaTerminals;
	}

	
	//ProgramUnit robot::ProgramUnit:
	//	{robot::ProgramUnit} block+=Expression*;
	public ProgramUnitElements getProgramUnitAccess() {
		return pProgramUnit;
	}
	
	public ParserRule getProgramUnitRule() {
		return getProgramUnitAccess().getRule();
	}
	
	//Expression flotCtrl::Expression:
	//	WhileLoop | NegExp | AndExp | IfBlock | Command;
	public ExpressionElements getExpressionAccess() {
		return pExpression;
	}
	
	public ParserRule getExpressionRule() {
		return getExpressionAccess().getRule();
	}
	
	//BoolExp flotCtrl::BoolExp:
	//	NegExp | AndExp | BOOLEAN_LITERAL | HasTurnedCmd | ObstacleCmd;
	public BoolExpElements getBoolExpAccess() {
		return pBoolExp;
	}
	
	public ParserRule getBoolExpRule() {
		return getBoolExpAccess().getRule();
	}
	
	//WhileLoop flotCtrl::WhileLoop:
	//	'while' loopCond=BoolExp 'do'
	//	block+=Expression*
	//	'end';
	public WhileLoopElements getWhileLoopAccess() {
		return pWhileLoop;
	}
	
	public ParserRule getWhileLoopRule() {
		return getWhileLoopAccess().getRule();
	}
	
	//NegExp flotCtrl::NegExp:
	//	'not' exp=BoolExp;
	public NegExpElements getNegExpAccess() {
		return pNegExp;
	}
	
	public ParserRule getNegExpRule() {
		return getNegExpAccess().getRule();
	}
	
	//AndExp flotCtrl::AndExp:
	//	'and' leftExp=BoolExp rightExp=BoolExp;
	public AndExpElements getAndExpAccess() {
		return pAndExp;
	}
	
	public ParserRule getAndExpRule() {
		return getAndExpAccess().getRule();
	}
	
	//IfBlock flotCtrl::IfBlock:
	//	'if' condition=BoolExp 'then'
	//	thenBlock+=Expression thenBlock+=Expression* ('else' elseBlock+=Expression elseBlock+=Expression*)?
	//	'end';
	public IfBlockElements getIfBlockAccess() {
		return pIfBlock;
	}
	
	public ParserRule getIfBlockRule() {
		return getIfBlockAccess().getRule();
	}
	
	//Command robot::Command:
	//	MoveCmd | ObstacleCmd | BipCmd | SetTurnAngleCmd | HasTurnedCmd | TurnCmd | StopEngineCmd | StopProgramCmd | PrintCmd;
	public CommandElements getCommandAccess() {
		return pCommand;
	}
	
	public ParserRule getCommandRule() {
		return getCommandAccess().getRule();
	}
	
	//PrintCmd robot::PrintCmd:
	//	'display' '(' ('msg' '=' msg=STRING ','?) & 'duration' '=' duration=INT ','? & 'line' '=' line=INT ','? & ('col' '='
	//	col=INT ','?)
	//	')';
	public PrintCmdElements getPrintCmdAccess() {
		return pPrintCmd;
	}
	
	public ParserRule getPrintCmdRule() {
		return getPrintCmdAccess().getRule();
	}
	
	//StopEngineCmd robot::StopEngineCmd:
	//	'stopEngine' '(' ')';
	public StopEngineCmdElements getStopEngineCmdAccess() {
		return pStopEngineCmd;
	}
	
	public ParserRule getStopEngineCmdRule() {
		return getStopEngineCmdAccess().getRule();
	}
	
	//StopProgramCmd robot::StopProgramCmd:
	//	'stopProgram' '(' ')';
	public StopProgramCmdElements getStopProgramCmdAccess() {
		return pStopProgramCmd;
	}
	
	public ParserRule getStopProgramCmdRule() {
		return getStopProgramCmdAccess().getRule();
	}
	
	//TurnCmd robot::TurnCmd:
	//	'turn' '(' ('power' '=' power=DOUBLE ','?) & ('angle' '=' angle=DOUBLE ','?)
	//	')';
	public TurnCmdElements getTurnCmdAccess() {
		return pTurnCmd;
	}
	
	public ParserRule getTurnCmdRule() {
		return getTurnCmdAccess().getRule();
	}
	
	//HasTurnedCmd robot::HasTurnedCmd:
	//	'hasTurned' '('
	//	'angle' '=' angle=DOUBLE
	//	')';
	public HasTurnedCmdElements getHasTurnedCmdAccess() {
		return pHasTurnedCmd;
	}
	
	public ParserRule getHasTurnedCmdRule() {
		return getHasTurnedCmdAccess().getRule();
	}
	
	//ObstacleCmd robot::ObstacleCmd:
	//	'obstacle' '('
	//	'distance' '=' distance=DOUBLE
	//	')';
	public ObstacleCmdElements getObstacleCmdAccess() {
		return pObstacleCmd;
	}
	
	public ParserRule getObstacleCmdRule() {
		return getObstacleCmdAccess().getRule();
	}
	
	//BipCmd robot::Bip:
	//	'bip' '(' ('duration' '=' duration=INT ','?) & 'power' '=' power=DOUBLE ','? & ('repeat' '=' repet=BOOLEAN_LITERAL
	//	','?)
	//	')';
	public BipCmdElements getBipCmdAccess() {
		return pBipCmd;
	}
	
	public ParserRule getBipCmdRule() {
		return getBipCmdAccess().getRule();
	}
	
	//SetTurnAngleCmd robot::SetTurnAngleCmd:
	//	'setTurnAngle' '('
	//	'angle' '=' angle=DOUBLE
	//	')';
	public SetTurnAngleCmdElements getSetTurnAngleCmdAccess() {
		return pSetTurnAngleCmd;
	}
	
	public ParserRule getSetTurnAngleCmdRule() {
		return getSetTurnAngleCmdAccess().getRule();
	}
	
	//MoveCmd robot::MoveCmd:
	//	'move' '('
	//	'power' '=' power=DOUBLE
	//	')';
	public MoveCmdElements getMoveCmdAccess() {
		return pMoveCmd;
	}
	
	public ParserRule getMoveCmdRule() {
		return getMoveCmdAccess().getRule();
	}
	
	//BOOLEAN_LITERAL ecore::EBoolean:
	//	'true' | 'false';
	public BOOLEAN_LITERALElements getBOOLEAN_LITERALAccess() {
		return pBOOLEAN_LITERAL;
	}
	
	public ParserRule getBOOLEAN_LITERALRule() {
		return getBOOLEAN_LITERALAccess().getRule();
	}
	
	//terminal STRING:
	//	'"' ('\\' ('b' | 't' | 'n' | 'f' | 'r' | 'u' | '"' | "'" | '\\') | !('\\' | '"'))* '"' |
	//	"'" ('\\' ('b' | 't' | 'n' | 'f' | 'r' | 'u' | '"' | "'" | '\\') | !('\\' | "'"))* "'";
	public TerminalRule getSTRINGRule() {
		return tSTRING;
	}
	
	//terminal ML_COMMENT:
	//	'/*'->'*/';
	public TerminalRule getML_COMMENTRule() {
		return tML_COMMENT;
	}
	
	//terminal SL_COMMENT:
	//	'//' !('\n' | '\r')* ('\r'? '\n')?;
	public TerminalRule getSL_COMMENTRule() {
		return tSL_COMMENT;
	}
	
	//terminal WS:
	//	' ' | '\t' | '\r' | '\n'+;
	public TerminalRule getWSRule() {
		return tWS;
	}
	
	//terminal fragment DIGIT:
	//	'0'..'9';
	public TerminalRule getDIGITRule() {
		return tDIGIT;
	}
	
	//terminal DOUBLE returns ecore::EDouble:
	//	INT ('.' DIGIT*);
	public TerminalRule getDOUBLERule() {
		return tDOUBLE;
	}
	
	//terminal INT returns ecore::EInt:
	//	'0' | '1'..'9' DIGIT*;
	public TerminalRule getINTRule() {
		return tINT;
	}
	
	//terminal ID:
	//	'^'? ('a'..'z' | 'A'..'Z' | '_') ('a'..'z' | 'A'..'Z' | '_' | '0'..'9')*;
	public TerminalRule getIDRule() {
		return gaTerminals.getIDRule();
	}
	
	//terminal ANY_OTHER:
	//	.;
	public TerminalRule getANY_OTHERRule() {
		return gaTerminals.getANY_OTHERRule();
	}
}
