/*
 * generated by Xtext 2.12.0
 */
package markHammil.mm.serializer;

import com.google.inject.Inject;
import java.util.Set;
import markHammil.mm.myDsl.BreakLineExpression;
import markHammil.mm.myDsl.EmphasisExpression;
import markHammil.mm.myDsl.Expression;
import markHammil.mm.myDsl.File;
import markHammil.mm.myDsl.Header1Expression;
import markHammil.mm.myDsl.Header2Expression;
import markHammil.mm.myDsl.Header3Expression;
import markHammil.mm.myDsl.Header4Expression;
import markHammil.mm.myDsl.Header5Expression;
import markHammil.mm.myDsl.Header6Expression;
import markHammil.mm.myDsl.ImageExpression;
import markHammil.mm.myDsl.ItalicExpression;
import markHammil.mm.myDsl.LineExpression;
import markHammil.mm.myDsl.LinkExpression;
import markHammil.mm.myDsl.ListExpression;
import markHammil.mm.myDsl.MyDslPackage;
import markHammil.mm.myDsl.NaturalExpression;
import markHammil.mm.myDsl.QuoteExpression;
import markHammil.mm.myDsl.RefExpression;
import markHammil.mm.myDsl.ScratchExpression;
import markHammil.mm.myDsl.StrongExpression;
import markHammil.mm.myDsl.TabExpression;
import markHammil.mm.myDsl.VideoExpression;
import markHammil.mm.services.MyDslGrammarAccess;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class MyDslSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private MyDslGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == MyDslPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case MyDslPackage.BREAK_LINE_EXPRESSION:
				sequence_BreakLineExpression(context, (BreakLineExpression) semanticObject); 
				return; 
			case MyDslPackage.EMPHASIS_EXPRESSION:
				sequence_EmphasisExpression(context, (EmphasisExpression) semanticObject); 
				return; 
			case MyDslPackage.EXPRESSION:
				sequence_Expression(context, (Expression) semanticObject); 
				return; 
			case MyDslPackage.FILE:
				sequence_File(context, (File) semanticObject); 
				return; 
			case MyDslPackage.HEADER1_EXPRESSION:
				sequence_Header1Expression(context, (Header1Expression) semanticObject); 
				return; 
			case MyDslPackage.HEADER2_EXPRESSION:
				sequence_Header2Expression(context, (Header2Expression) semanticObject); 
				return; 
			case MyDslPackage.HEADER3_EXPRESSION:
				sequence_Header3Expression(context, (Header3Expression) semanticObject); 
				return; 
			case MyDslPackage.HEADER4_EXPRESSION:
				sequence_Header4Expression(context, (Header4Expression) semanticObject); 
				return; 
			case MyDslPackage.HEADER5_EXPRESSION:
				sequence_Header5Expression(context, (Header5Expression) semanticObject); 
				return; 
			case MyDslPackage.HEADER6_EXPRESSION:
				sequence_Header6Expression(context, (Header6Expression) semanticObject); 
				return; 
			case MyDslPackage.IMAGE_EXPRESSION:
				sequence_ImageExpression(context, (ImageExpression) semanticObject); 
				return; 
			case MyDslPackage.ITALIC_EXPRESSION:
				sequence_ItalicExpression(context, (ItalicExpression) semanticObject); 
				return; 
			case MyDslPackage.LINE_EXPRESSION:
				sequence_LineExpression(context, (LineExpression) semanticObject); 
				return; 
			case MyDslPackage.LINK_EXPRESSION:
				sequence_LinkExpression(context, (LinkExpression) semanticObject); 
				return; 
			case MyDslPackage.LIST_EXPRESSION:
				sequence_ListExpression(context, (ListExpression) semanticObject); 
				return; 
			case MyDslPackage.NATURAL_EXPRESSION:
				sequence_NaturalExpression(context, (NaturalExpression) semanticObject); 
				return; 
			case MyDslPackage.QUOTE_EXPRESSION:
				sequence_QuoteExpression(context, (QuoteExpression) semanticObject); 
				return; 
			case MyDslPackage.REF_EXPRESSION:
				sequence_RefExpression(context, (RefExpression) semanticObject); 
				return; 
			case MyDslPackage.SCRATCH_EXPRESSION:
				sequence_ScratchExpression(context, (ScratchExpression) semanticObject); 
				return; 
			case MyDslPackage.STRONG_EXPRESSION:
				sequence_StrongExpression(context, (StrongExpression) semanticObject); 
				return; 
			case MyDslPackage.TAB_EXPRESSION:
				sequence_TabExpression(context, (TabExpression) semanticObject); 
				return; 
			case MyDslPackage.VIDEO_EXPRESSION:
				sequence_VideoExpression(context, (VideoExpression) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     BreakLineExpression returns BreakLineExpression
	 *
	 * Constraint:
	 *     {BreakLineExpression}
	 */
	protected void sequence_BreakLineExpression(ISerializationContext context, BreakLineExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TextExpression returns EmphasisExpression
	 *     EmphasisExpression returns EmphasisExpression
	 *
	 * Constraint:
	 *     (c+=StrongExpression | c+=ItalicExpression | c+=ScratchExpression | c+=NaturalExpression)+
	 */
	protected void sequence_EmphasisExpression(ISerializationContext context, EmphasisExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Expression
	 *
	 * Constraint:
	 *     (c=HeaderExpression | c=BreakLineExpression | c=RefExpression | c=ListExpression | c=TextExpression)
	 */
	protected void sequence_Expression(ISerializationContext context, Expression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     File returns File
	 *
	 * Constraint:
	 *     expression+=Expression*
	 */
	protected void sequence_File(ISerializationContext context, File semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     HeaderExpression returns Header1Expression
	 *     Header1Expression returns Header1Expression
	 *
	 * Constraint:
	 *     title+=EmphasisExpression
	 */
	protected void sequence_Header1Expression(ISerializationContext context, Header1Expression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     HeaderExpression returns Header2Expression
	 *     Header2Expression returns Header2Expression
	 *
	 * Constraint:
	 *     title+=EmphasisExpression
	 */
	protected void sequence_Header2Expression(ISerializationContext context, Header2Expression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     HeaderExpression returns Header3Expression
	 *     Header3Expression returns Header3Expression
	 *
	 * Constraint:
	 *     title+=EmphasisExpression
	 */
	protected void sequence_Header3Expression(ISerializationContext context, Header3Expression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     HeaderExpression returns Header4Expression
	 *     Header4Expression returns Header4Expression
	 *
	 * Constraint:
	 *     title+=EmphasisExpression
	 */
	protected void sequence_Header4Expression(ISerializationContext context, Header4Expression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     HeaderExpression returns Header5Expression
	 *     Header5Expression returns Header5Expression
	 *
	 * Constraint:
	 *     title+=EmphasisExpression
	 */
	protected void sequence_Header5Expression(ISerializationContext context, Header5Expression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     HeaderExpression returns Header6Expression
	 *     Header6Expression returns Header6Expression
	 *
	 * Constraint:
	 *     title+=EmphasisExpression
	 */
	protected void sequence_Header6Expression(ISerializationContext context, Header6Expression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TextExpression returns ImageExpression
	 *     ImageExpression returns ImageExpression
	 *
	 * Constraint:
	 *     (altText=NaturalExpression linkContent=NaturalExpression?)
	 */
	protected void sequence_ImageExpression(ISerializationContext context, ImageExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ItalicExpression returns ItalicExpression
	 *
	 * Constraint:
	 *     content=EmphasisExpression
	 */
	protected void sequence_ItalicExpression(ISerializationContext context, ItalicExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.ITALIC_EXPRESSION__CONTENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.ITALIC_EXPRESSION__CONTENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getItalicExpressionAccess().getContentEmphasisExpressionParserRuleCall_2_0(), semanticObject.getContent());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     LineExpression returns LineExpression
	 *
	 * Constraint:
	 *     (cells+=NaturalExpression cells+=NaturalExpression*)
	 */
	protected void sequence_LineExpression(ISerializationContext context, LineExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TextExpression returns LinkExpression
	 *     LinkExpression returns LinkExpression
	 *
	 * Constraint:
	 *     ((altText=NaturalExpression linkContent=NaturalExpression?) | (altText=NaturalExpression refName=NaturalExpression?))
	 */
	protected void sequence_LinkExpression(ISerializationContext context, LinkExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ListExpression returns ListExpression
	 *
	 * Constraint:
	 *     (contentUnordered+=TextExpression+ | contentOrdered+=TextExpression+)
	 */
	protected void sequence_ListExpression(ISerializationContext context, ListExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     NaturalExpression returns NaturalExpression
	 *
	 * Constraint:
	 *     value+=Content
	 */
	protected void sequence_NaturalExpression(ISerializationContext context, NaturalExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TextExpression returns QuoteExpression
	 *     QuoteExpression returns QuoteExpression
	 *
	 * Constraint:
	 *     content+=TextExpression+
	 */
	protected void sequence_QuoteExpression(ISerializationContext context, QuoteExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RefExpression returns RefExpression
	 *
	 * Constraint:
	 *     (refName=NaturalExpression refContent=NaturalExpression?)
	 */
	protected void sequence_RefExpression(ISerializationContext context, RefExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ScratchExpression returns ScratchExpression
	 *
	 * Constraint:
	 *     content=EmphasisExpression
	 */
	protected void sequence_ScratchExpression(ISerializationContext context, ScratchExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.SCRATCH_EXPRESSION__CONTENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.SCRATCH_EXPRESSION__CONTENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getScratchExpressionAccess().getContentEmphasisExpressionParserRuleCall_2_0(), semanticObject.getContent());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     StrongExpression returns StrongExpression
	 *
	 * Constraint:
	 *     content=EmphasisExpression
	 */
	protected void sequence_StrongExpression(ISerializationContext context, StrongExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.STRONG_EXPRESSION__CONTENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.STRONG_EXPRESSION__CONTENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStrongExpressionAccess().getContentEmphasisExpressionParserRuleCall_2_0(), semanticObject.getContent());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     TextExpression returns TabExpression
	 *     TabExpression returns TabExpression
	 *
	 * Constraint:
	 *     (header=LineExpression lines+=LineExpression*)
	 */
	protected void sequence_TabExpression(ISerializationContext context, TabExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TextExpression returns VideoExpression
	 *     VideoExpression returns VideoExpression
	 *
	 * Constraint:
	 *     (altText=NaturalExpression linkImage=NaturalExpression? linkVideo=NaturalExpression?)
	 */
	protected void sequence_VideoExpression(ISerializationContext context, VideoExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
